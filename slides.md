 Современные технологии в программировании
Лекции 1-2 Основные принципы и краткое введение

---

 Контактная информация
• Преподаватель
• Епонешников Александр Вячеславович • Телеграм: @Eponeshnikov

---

 План курса
• ВведениевPython
• Создание приложений с GUI
• Анализ данных на Python • АвтоматизацияML

---

 Требуемые предварительные знания
 Курс самодостаточный, требует только базовых знаний математики и здравый смысл :)
Однако я ожидаю, что у вас есть некоторый опыт программирования на других языках.
Желание учиться - ключевое предварительное условие!
Только 50% материала будет дано на лекциях/практических занятиях; остальное - предмет вашего собственного изучения.

---

Перед тем как начать...
Замечание о синтаксисе и семантике языка
 Синтаксис: набор правил, регулирующих структуру программ и их частей (конструкций).
Семантика: значение конструкций.
Статическая семантика:
- как программы компилируются. Динамическая семантика: -как программы выполняются.
«Обычный» взгляд на язык:
 Syntax
 Semantics

---


Перед тем как
начать...
Реальность:
Замечание о синтаксисе и семантике языка
Вывод для программистов:
-Уделяйте основное внимание семантике языка, а не синтаксису.
   Semantics
  Syntax
Вы должны быть способны выучить синтаксис нового
языка всего за неделю упражнений.
одну

---


 План на сегодня
• Почему Python?
• Что такое Python?
• Структура программы и первый пример
• Статический vs динамический
• Модель выполнения Python
• Объектная модель Python
• Примеры программ
• Функции!

---


Почему Python?
Очень популярный язык.
1е место в индексе TIOBE:
https://www.tiobe.com/tiobe-index/
• 1е место в
рейтинге языков
программирования
IEEE Spectrum за
2023:
https://spectrum.ieee.org/the-top-programming- languages-2023

---

Почему Python?
• Очень популярный язык: 1-ые места в авторитетных рейтингах.
• Очень большая стандартная библиотека.
• Огромное количество библиотек
сторонних разработчиков.
• Богатый набор мощных структур данных
на уровне языка.
• Простой в изучении, простой в
программировании.
Guido van Rossum

---

Основные характеристики Python
• Языквысокогоуровня.
Полный набор традиционных средств языка: переменные, типы, выражения,
операторы, функции, исключения и т.д.
• Объектно-ориентированныйязык.
Классы с одиночным наследованием (и ограниченной поддержкой
множественного наследования), виртуальные методы.
• Функциональныйязык.
Функции как "объекты первого класса"; лямбда-функции; генераторы.
• "Модульный"язык.
Программы на Python могут состоять из отдельных взаимодействующих блоков –
модулей.
• Динамическитипизированныйязык.
Типы объектов не фиксированы: переменная может содержать значения любого
 типа; нет явных объявлений переменных.
• Интерпретируемыйязык. Посмотрим позже...

---

Статическая и динамическая типизация: + и -
 Статическая типизация:
 Требует больше усилий при написании программы: нужно явно указывать типы объектов.
 Программа более безопасна: многие ошибки обнаруживаются до запуска (на этапе компиляции).
 Программа более читаема; ее легче читать, понимать и поддерживать.
Жесткая привязка между переменной и ее типом: x может принимать любые значения, но тип значения должен быть всегда одним и тем же.
---
C, C++, Java, Scala, C#, Eiffel, ...
  type
name
value
      int x;
...
x = 7; // OK
...
x = "string"; // error

Статическая и динамическая типизация: + и -
Динамическая типизация:
 Гораздо проще писать программу: не нужно заботиться о типах объектов.
 Программа более гибкая: не нужно вводить разные объекты для разных целей.
 Программа часто выглядит непонятной; требуются гораздо большие усилия, чтобы понять и поддерживать ее.
 Программы небезопасны и неэффективны.
 Javascript, Python, Ruby, ...
  type
name
value
       x = 7; // OK
 ...
//
 OK! OK!
 x = "string";
 ...
 y = x + 7; //
 Формально правильно, но что, черт возьми, это значит??
Мягкая привязка между переменной и ее типом: x может содержать любое значение любого типа.
---

Статическая и динамическая типизация: + и -
Почему динамические программы менее безопасны?
a*b
  В статическом языке: компилятор проверяет типы a и b и делает вывод (до запуска программы), допустима ли операция умножения для этих типов. Если типы неподходящие, компилятор сообщает об ошибке, и ошибка может быть исправлена до запуска программы.
В динамическом языке: компилятор ничего не знает о типах a и b, поэтому не может судить, верен ли этот код или нет.
Обычно компилятор доверяет программисту и считает код верным. Для некоторых значений a и b код может быть действительно верным, но для других может быть ошибочным.
Ошибка может возникнуть только во время выполнения программы, иногда через долгое время после написания...
---

Статическая и динамическая типизация: + и -
Почему динамические программы менее безопасны?
a*b
  В статическом языке: компилятор точно знает, что a и b имеют целочисленный тип. Поэтому он генерирует компактный и быстрый код:
В динамическом языке: компилятор ничего не знает о типах a и b, поэтому должен обеспечить код для всех возможных случаев:
 if a, b are integers: Выполнить целочисленное
умножение
else if a, b are strings:
Выполнить конкатенацию строк else if a is string, b is integer:
Создать повторение как a+a+a else if a is integer, b is string:
Преобразовать a в строку, выполнить конкатенацию строк
...
 • Загрузить целые числа a и b в стек
• Выполнить целочисленное умножение
• Удалить операнды из стека и поместить результат в стек
---

Это (неявное) объявление нового объекта. Мы указываем его имя odds и начальное значение...
Это
объявление
другого объекта.
Это обычный
оператор условия
с обычной семантикой
Обратите внимание на отступы и забавный синтаксис
Начальное значение для right_this_minute задается как выражение (см. следующий слайд).
Python: первый пример
  Импорт подмодуля datetime, который является частью модуля с тем же именем (Ну, нам придется с этим смириться )
Начальным значением odds является список. Список состоит из значений (литералов) целочисленного типа.
   from datetime import datetime
odds=[1, 3, 5, 7, 9,11,13,15,17,19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59]
right_this_minute = datetime.today().minute
if right_this_minute in odds:
print("This minute seems a litte odd.")
else:
print("Not and odd minute.")
---

Python: первый пример
    Аналогичный код: Вопрос:Что лучше?
 time_now = datetime.today() right_this_minute = time_now.minute
• Здесь мы вызываем функцию today из подмодуля datetime, используя точечную нотацию (как в Java). Результатом вызова является составной объект, содержащий информацию о текущем времени (атрибуты - час, минута и т.д.).
  from datetime import datetime
odds = ...
• Вторая точечная конструкция берет атрибут minute из составного объекта.
• Результат всего выражения присваивается переменной right_this_minute.
 right_this_minute = datetime.today().minute
if right_this_minute in odds:
    print("This minute seems a litte odd.")
else:
    print("Not and odd minute.")
Оператор in используется для проверки, является ли один объект частью другого. Здесь он проверяет, является ли значение, взятое из minute, элементом списка odds. В зависимости от результата проверки оператор in возвращает либо True, либо False.
---
     
Структура программы Python
  from datetime import datetime
odds = ...
right_this_minute = datetime.today().minute
if right_this_minute in odds:
print("This minute seems a litte odd.")
else:
    print("Not and odd
minute.")
     Code block
!!!
Module
Code block Code block
    Отступы используются для обозначения блоков кода.
Следствия:
• Нет необходимости в фигурных скобках
• Добавляется забавная ':'
    Code block 1
   Code block 2
    Code block 3
   Code block 2, continuation
    Code block 1, continuation
---

Составные операторы
  Общий синтаксис:
Заголовок составного оператора :
    Тело составного оператора(code block)
 Примеры:
Фактически, отступы - не строгое правило:
for i in [1,2,3]:
       print(i)
 if expression: print("Yes")
else:
       print("No")
 if expression: print("Yes") else: print("No")
  def fun(a): return a*a
 def fun(a): return a*a
 Эти формы тоже легальны 
---

Модель выполнения Python
 Интерпретация: Программы Python выполняются построчно
Input
  from datetime import datetime
odds=[1, 3, 5, 7, 9,11,13,15,17,19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59]
right_this_minute = datetime.today().minute
if right_this_minute in odds:
print("This minute seems a litte odd.")
else:
print(“Not and odd minute.")
Важное замечание:
Внутренне интерпретатор Python работает очень похоже на виртуальную машину Java: он преобразует ввод в промежуточное представление ("байт-код") и выполняет его.
Но этот механизм полностью скрыт от программистов: нет "class-файлов" как в Java.
---
Python Interpreter
 Построчно выполняет ввод
Выводит результат выполнения в стандартное устройство вывода/файл
 
Модель выполнения Python
Два способа программирования на Python (т.е. два способа задания ввода):
  Ввод может быть задан как полная программа Python (модуль) в файле на диске, ИЛИ
Ввод может быть введен интерактивно
Для экспериментов
Для реального программирования
  IDLE: простая оболочка для Python
---

Система объектов Python
 Принцип 1:
Все является объектом – переменные, функции, классы (!), модули (!!).
Принцип 2:
Каждая "переменная" является ссылкой.
 Используя терминологию Java, все типы в Python являются ссылочными – даже целые, вещественные и т.д.
 Каждый объект представлен как пара:
• Значение объекта (т.е. сам объект)
• Ссылка на объект
   variable
The object
---

Система объектов Python
   a = [ 1, 2, 3]
Stack
...
Heap
The object (list)
  1
 2
 3
 Один и тот же принцип для всех типов объектов
  b = 77
a
 Stack
...
Heap
The object (integer)
77
   b
---

Система объектов Python
   Присваивание манипулирует ссылками
    1
 2
 3
  >>> a = [ 1, 2, 3]
  1
 2
 3
   >>> b = a
a
 a
 b
   1
 2
 3
 4
a
 >>> a.append(4)
>>> print(b)
[1,2,3,4]
   b
---

Система объектов Python
  Присваивание манипулирует ссылками
   >>> a = 1
a
     a
  >>> b = a
1
1
   b
  >>> a = a+1
 Подробная семантика: 1.Создается и инициализируется
новый целочисленный объект
значением a+1.
2. Ссылка на новый объект
присваивается a (заменяя старую ссылку).
 2
1
  a
    b
---

Присваивания: некоторые хитрости
• Если вам лень писать серию присваиваний, вы можете записать все в одной строке:
x=y=z=7
• Несколько разных присваиваний можно объединить в одно ("параллельное присваивание"):
x, y = 7, 9
  x=7 y=7 z=7
   Семантика:
1.Выражения с правой части вычисляются последовательно. 2.Затем значения последовательно присваиваются переменным из левой части.
---

Python: Функции
 Темы:
• Функции
• Функции как объекты • Вложенные функции • Лямбда-функции
• Декораторы
---

Python: Функции
• Вероятно, самый важный механизм в каждом языке программирования
• Используется для рефакторинга и структурирования программ
• Основа для повторного использования кода
Если вам нужно выполнить часть кода несколько раз для разных
входных значений – вы объявляете эту часть как функцию.
• Ключевое понятие в функциональном программировании
  Функция Процедура
Метод Подпрограмма
---

Пример функции
  Заголовок функции: ключевое слово def, имя функции, список формальных параметров (если есть)
Документирование функции: строка в тройных кавычках
  def gcd(a,b):
'''Возвращает наибольший общий делитель двух чисел'''
while a != 0 :
a, b = b%a, a # Параллельное присвоение
return b
   Тело функции: последовательность операторов с отступами
Оператор return возвращает значение в вызывающую функцию..
Комментарий: начинается с # и заканчивается в конце строки
• Функции могут возвращать значения; функции могут не возвращать значений (или возвращать None).
• Функции могут иметь параметры: либо фиксированное число параметров, либо произвольное число параметров.
• Функции являются объектами в Python, см. следующий слайд.
---

Пример функции
Имея эту функцию...
  def gcd(a,b):
'''Возвращает наибольший общий делитель двух чисел'''
while a != 0 :
a, b = b%a, a # Параллельное присвоение
return b
...что мы можем с ней делать?
- Конечно, вызывать! gcd(12,20)
 >>>gcd(12,20)
4
>>>x = gcd(5,10) >>>x
5
   Имя функции
Список фактических параметров или аргументов
---

Пример функции
  def gcd(a,b):
'''Возвращает наибольший общий делитель двух чисел'''
while a != 0 :
a, b = b%a, a # Параллельное присвоение
return b
Что еще мы можем делать с функцией?
- Мы можем присвоить функцию переменной!
- Мы можем передавать функцию как аргумент другой функции!
- Мы можем возвращать функцию как результат некоторой другой функции
Все это означает, что функции являются объектами в Python
- как и обычные переменные
– а также как в некоторых других языках.
---

Функции - объекты
В чем разница между f(7) и f?
  def f(a): return a*a
x = f(7) g=f
f(7) g(7)
f (ссылка на) объект (функционального типа)
f(7) оператор вызова, примененный к функциональному объекту
       Эти два вызова обращаются к одной и той же функции
---

Здесь мы используем функцию, чтобы активировать ее алгоритм
Здесь мы получаем доступ к атрибуту функции, имя которого __doc__.
Функции - объекты
  def fib(n):
        ''' Печатает числа Фибоначчи до n'''
a, b = 0, 1 while b < n :
print(b)
a, b = b, a+b
 Заметьте: эта функция не возвращает значения
 fib(2000)
1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597
  def doAction(n,action):
''' Выполняет некоторое действие с n'''
        action(n)
doAction(2000,fib)
Здесь мы передаем
  функцию другой функции в качестве аргумента
 >>>gcd. doc
'Returns greatest common divisor'
---

Функции - объекты
Пример: функция возвращает функции
  def chooseAction(n): def sqr(a):
return a*a def cubic(a):
return a*a*a def quad(a):
return a*a*a*a
if n == 2:
return sqr
elif n == 3:
return cubic
     else:
return quad
Вложенные функции
Это не вызовы, а имена функциональных объектов!
---

 Часть 2 Подробнее о функциях
---

Ссылки и привязка значений
Напоминание: все сущности являются объектами в Python, включая переменные, функции, классы.
Вот общая схема (снова):
Значение, код функции, объект класса и т.д.
     identifier = Expression
def identifier ( parameters ): FunctionBody
class identifier: ClassBody
  identifier
  The object
Ключевой момент: связь между идентификатором (ссылкой) и ссылаемым объектом слабая: она может динамически меняться во время выполнения программы.
---

Пример:
Ссылки и привязка значений
   def fun(n): return n*n
...
fun = 777
...
class fun:
pass ...
del fun
 Function
  code
   fun
Lost!
777 Lost! Lost!
 Class object
 Удаляет fun из текущей области видимости
---

Типизация
 Обычно типы параметров и тип возвращаемого значения не указываются. Однако в Python есть аннотации типов:
    def cube(a):
  return a*a*a
Аннотации типов не влияют на семантику программы.
Python никогда не проверяет типы. Аннотации служат исключительно для документирования функций.
Типы
  def cube(a:int)->int:
  return a*a*a
 int set str ...
Введите help(fun-name), чтобы получить документацию по функциям вместе с аннотациями типов.
---

Параметры функций Параметры по умолчанию
 Обычно функция может быть
 вызвана аргументов, количеству параметров.
с количеством
точно равным
ее формальных
Однако можно указать значение по умолчанию для одного или всех параметров.
   def cube(a): return a*a*a
def cube(a = 9): return a*a*a
 c1 = cube(7) #
 OK
Error
 c2 = cube() #
 c3 = cube(1,7) #
 Error
  c = cube(7) #OK 1
  c= cube() #OK 2
 #Также
как cube(9)
Правило: если у параметра есть значение по умолчанию, то все параметры после него тоже должны иметь значения по умолчанию.
---

Параметры функций Позиционные и именованные параметры
 Обычно соответствие между параметрами функции и аргументами вызова определяется их позициями:
 12
 def power(base,exponent):
  return base**exponent
   p = power(7,10)
12
Первый аргумент соответствует первому формальному параметру: base получает значение 7.
Второй аргумент соответствует второму параметру: exponent получает значение 10.
---

Параметры функций Позиционные и именованные параметры
 В дополнение к позиционным аргументам, можно вызывать функцию, указывая имена параметров.
 В этом случае порядок аргументов в вызове неважен.
 12
 def power(base,exponent):
  return base**exponent
   p = power(base=7,exponent=10)
12
p = power(exponent=10,base=7)
21
Преимущества:
• Больше свободы
• Лучшая читаемость, особенно при большом числе параметров
---

Произвольное число аргументов
 В некоторых практических случаях кажется полезным дать функции еще большую гибкость – сделать ее применимой к произвольному числу аргументов.
 Типичный пример: функция print. Вместо множества разных функций печати, принимающих один, два, три и более аргументов, хорошая идея иметь одну функцию для всех этих случаев.
  Символ '*' указывает, что функция может быть вызвана с произвольным числом аргументов – даже с нулем.
    def process(*items):
      ...
Здесь items можно рассматривать как «групповое имя» для всех аргументов. (Технически, это кортеж (tuple).)
    Соглашение Python рекомендует использовать args как групповое имя.
---

Произвольное число аргументов
Как функция может обрабатывать произвольные аргументы?
Пример
def process(action, *items):
'''Применяет "action" к элементам и возвращает сумму''' sum = 0
for item in items:
   sum += action(item) return sum
Функция высшего порядка
Перед вызовом функции process Python собирает все аргументы (начиная со второго) в один кортеж и передает его функции целиком.
   def quad(n): return n*n
quad_sum = process(quad,1,2,3,4,5,6)
empty_sum = process(quad) # returns 0
---

Один аргумент во многие
def process(action, *items):
'''Применяет "action" к элементам и возвращает сумму''' sum = 0
for item in items:
    sum += action(item)
  return sum
    Здесь мы передаем только один
аргумент (это список) функции process. Возможно ли как-то представить один список как последовательность аргументов, чтобы функция могла обработать их?
 def quad(n): return n*n
values = [1,2,3,4,5,6]
quad_sum = process(quad,values)
 ...Или развернуть список в последовательность аргументов?
quad_sum = process(quad,*values)
Символ "*" перед аргументом (не перед параметром, как раньше) приводит к преобразованию структуры данных в простую последовательность элементов.
---
    
Один аргумент во многие(еще раз)
  Упражнение (незадание)
Напишите разумную функцию, которая принимает произвольное число именованных аргументов.
Для этого вам нужно самостоятельно изучить случай с символами “**” перед аргументом.
---

 Итог: Чему мы научились
• Структура программы Python
• Статическая и динамическая типизация Python
Python - эт о динамически т ипизированный язык
• Модель выполнения Python
Программы Python интерпретируются (Не совсем;
подробности дальше)
• Система объектов Python Все - объект!
• Функции
Функции - т оже объект ы
---
